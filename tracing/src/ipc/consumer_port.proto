/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";
option optimize_for = LITE_RUNTIME;

import "tracing/src/ipc/data_source_config.proto";

package perfetto;

// IPC interface definition for the consumer port of the tracing service.
service ConsumerPort {
  rpc StartTracing(StartTracingRequest) returns (StartTracingResponse) {}
  rpc StopTracing(StopTracingRequest) returns (stream StopTracingResponse) {}
  // TODO rpc ListDataSources(), for the UI.
}

// Arguments for rpc StartTracing().
message StartTracingRequest {
  message BufferConfig {
    uint32 size_kb = 1;
    // TODO: enum Policy { RING_BUFFER, STOP_WHEN_FULL }
  }
  repeated BufferConfig buffers = 1;

  message DataSource {
    // Filters and data-source specific config. It contains also the unique name
    // of the data source, the one passed in the  DataSourceDescriptor when they
    // register on the service.
    proto.DataSourceConfig config = 1;

    // Optional. If multilple producer (~processes) expose the same data source
    // and |producer_name_filter| != "", the data source is enabled only for
    // producers which name match any of the producer_name_filter below.
    // This allow to enable a data source only on specific processes.
    repeated string producer_name_filter = 2;
  }
  repeated DataSource data_sources = 2;

  enum DrainMode {
    // The log buffer is sent to the Consumer only after the StopTracing()
    // command. This mode minimizes the Service overhead when moving the pages
    // from the Producer(s) shared staging buffers into the central log buffer,
    // at the cost of doing some extra memory moves to reorder and reassemble
    // the logged TracePacket(s).
    COLLECT_ON_STOP = 0;

    // The log buffer is streamed continuously to the Consumer.
    // Advantages:
    // - It allows to use a smaller log buffer size, as the buffer is only
    //   needed to cover piping latency of the Consumer.
    // - It reduce the total cpu cost of tracing, as TracePackets are reshuffled
    //   only once when collected from the Produer(s) staging buffers.
    // Disadvantage:
    // - More scheduling intrusive, as will periodically wake up the Consumer
    //   to stream data.
    // TODO: Not implemented yet.
    // STREAM_IN_REAL_TIME = 1;
  }
  DrainMode drain_mode = 3;
}

message StartTracingResponse {}

message StopTracingRequest {}

message StopTracingResponse {
  // Each streaming reply returns one or more trace packets (see
  // trace_packet.proto).
  // Why "bytes" here? If we just return the full TracePacket object, that will
  // force the Consumer to deserialize it. In many occasions, the Consumer will
  // not consume the TracePacket(s) locally but will just forward them over
  // the network or save them to a file. Deserializing them on-device would be
  // a waste of time, memory and energy.

  // TODO: in the past we agreed that a TracePacket can be very large (MBs).
  // However here it will hit the limit of the IPC layer in order to keep
  // the socket buffer bounded. On one side we could upgrade this protocol to
  // support chunks, so we could directly propagate the chunked TracePacket
  // stored in the log buffer. On the other side, this will likely just move
  // the problem on the consumer, that will need larger buffers for reassembly.
  // Perhaps we should just cap the size of a TracePacket to a lower size?
  repeated bytes trace_packets = 1;
}
